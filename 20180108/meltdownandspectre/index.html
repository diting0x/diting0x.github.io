<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>一步一步理解CPU芯片漏洞：Meltdown与Spectre - 善守者</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="作者：Diting0x 0X00 历史之日2018年1月3日，Google Project Zero（GPZ）团队安全研究员Jann Horn在其团队博客中爆出CPU芯片的两组漏洞，分别是Meltdown与Spectre。 Meltdown对应CVE-2017-5754（恶意数据缓存加载），Spectre对于CVE-2017-5753（边界检查绕过）与CVE-2017-5715（分支目标注入）。看">
<meta name="keywords" content="Meltdown,Spectre,Vulnerability">
<meta property="og:type" content="article">
<meta property="og:title" content="一步一步理解CPU芯片漏洞：Meltdown与Spectre">
<meta property="og:url" content="https://diting0x.github.io/20180108/meltdownandspectre/index.html">
<meta property="og:site_name" content="善守者">
<meta property="og:description" content="作者：Diting0x 0X00 历史之日2018年1月3日，Google Project Zero（GPZ）团队安全研究员Jann Horn在其团队博客中爆出CPU芯片的两组漏洞，分别是Meltdown与Spectre。 Meltdown对应CVE-2017-5754（恶意数据缓存加载），Spectre对于CVE-2017-5753（边界检查绕过）与CVE-2017-5715（分支目标注入）。看">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://oij0laovn.bkt.clouddn.com/anquanke.jpeg">
<meta property="og:image" content="http://oij0laovn.bkt.clouddn.com/banner.png">
<meta property="og:image" content="http://oij0laovn.bkt.clouddn.com/gdb.png">
<meta property="og:image" content="http://oij0laovn.bkt.clouddn.com/result.png">
<meta property="og:updated_time" content="2018-01-08T14:38:39.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一步一步理解CPU芯片漏洞：Meltdown与Spectre">
<meta name="twitter:description" content="作者：Diting0x 0X00 历史之日2018年1月3日，Google Project Zero（GPZ）团队安全研究员Jann Horn在其团队博客中爆出CPU芯片的两组漏洞，分别是Meltdown与Spectre。 Meltdown对应CVE-2017-5754（恶意数据缓存加载），Spectre对于CVE-2017-5753（边界检查绕过）与CVE-2017-5715（分支目标注入）。看">
<meta name="twitter:image" content="http://oij0laovn.bkt.clouddn.com/anquanke.jpeg">
  
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">谛听</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/timeline">Timeline</a>
        
          <a class="main-nav-link" href="/shoulders">Shoulders</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://diting0x.github.io"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-meltdownandspectre" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      一步一步理解CPU芯片漏洞：Meltdown与Spectre
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/20180108/meltdownandspectre/" class="article-date">
  <time datetime="2018-01-08T13:03:06.000Z" itemprop="datePublished">2018-01-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/漏洞分析/">漏洞分析</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<h2 id="0X00-历史之日"><a href="#0X00-历史之日" class="headerlink" title="0X00 历史之日"></a>0X00 历史之日</h2><p>2018年1月3日，Google Project Zero（GPZ）团队安全研究员Jann Horn在其<a href="https://googleprojectzero.blogspot.hk/2018/01/reading-privileged-memory-with-side.html" target="_blank" rel="external">团队博客</a>中爆出CPU芯片的两组漏洞，分别是Meltdown与Spectre。</p>
<p>Meltdown对应CVE-2017-5754（恶意数据缓存加载），Spectre对于CVE-2017-5753（边界检查绕过）与CVE-2017-5715（分支目标注入）。看CVE编号就能知道，这两组漏洞早在2017年6月就已经由GPZ团队向英特尔提交，而在差不多时间由Lipp等人发布的论文<a href="https://meltdownattack.com/meltdown.pdf" target="_blank" rel="external">Meltdown</a>与<a href="https://spectreattack.com/spectre.pdf" target="_blank" rel="external">Spectre Attacks</a>也详细描述了这一攻击，从文中的声明来看，Lipp等人与GPZ团队似乎是独立发现了这两组漏洞。为什么去年6月就提交的漏洞到现在才正式公布呢？更有趣的是下图：</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/anquanke.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/anquanke.jpeg" width="450"></a><br>    <figcaption></figcaption><br></figure>

<p>原因不得而知，得问Intel去了。</p>
<p>Meltdown漏洞影响几乎所有的Intel CPU和部分ARM CPU，而Spectre则影响所有的Intel CPU和AMD CPU，以及主流的ARM CPU。从个人电脑、服务器、云计算机服务器到移动端的智能手机，都受到这两组硬件漏洞的影响。这必将是要在安全界乃至整个计算机界载入史册的重要日子，各种报道与公告乃至技术细节充斥着整个朋友圈、微博与媒体，可以说是路人皆知了。为何这两个漏洞如此特别，引起大家如此重视呢？ 请往下看。</p>
<h2 id="0X01-漏洞原理"><a href="#0X01-漏洞原理" class="headerlink" title="0X01 漏洞原理"></a>0X01 漏洞原理</h2><p>这两组漏洞来源于芯片厂商为了提高CPU性能而引入的两种特性：乱序执行（Out-of-Order Execution）和预测执行(Speculative Execution)。</p>
<p>早期的处理器依次顺序执行既定的处理器指令，而现代处理器为了提高性能并不严格按照指令的顺序串行执行，而是对执行进行相关性分析后并行处理乱序执行。比如当处理器中的某些指令需要等待某些资源，处理器不会真的在这里等待而停止指令的执行，而是利用等待资源的时间继续执行后续的指令。在支持乱序执行的CPU中，后面的指令可能在前面指令执行结束前就开始执行了。为了保证程序运行的正确性，处理器会对指令执行安全检查，只有当前用户权限符合指令权限时才能被执行，比如用户空间的指令访问内核内存处理器就会抛出异常。然而安全检查这个操作只有在指令退休（retirement-一条指令退休只有当它的执行的结果真正被提交并对系统可见时才会发生）时才会进行。也就是说，如果在乱序执行中，指令并没有真正执行而只是加载到缓存中（下文会提）是不会执行安全检查的，正是安全检查与乱序执行的空窗期才会让Meltdown有机可乘。</p>
<p>预测执行涉及到程序的控制流，现在处理器不是去解析所有分支指令后然后决定执行哪个操作，而是预测哪个控制流会更有可能被运行再提取相应的指令代码执行。如果预测正确的话，会带来很高的性能提升并提高处理器的并行性。如果预测错误，那些被预测执行或被乱序执行的不正确结果会被丢弃，处理器会将状态恢复到预测执行或乱序执行前的正确状态，再重新跳转到正确执行的分支或指令中运行。这种机制从宏观上看似乎没什么问题，但由于处理器的缓存（cache）机制，那些被预测执行或乱序执行的指令会被先加载到缓存中，但在处理器恢复状态时并不会恢复处理器缓存的内容。而最新的研究表明攻击者可以利用缓存进行侧信道攻击，而Meltdown与Spectre从本质上来看属于利用处理器的乱序执行或预测执行漏洞进行的缓存侧信道攻击。</p>
<p>基于缓存的侧信道攻击目前在学术界研究中非常流行，比如俄亥俄州立大学的<a href="http://web.cse.ohio-state.edu/~zhang.834/" target="_blank" rel="external">Yinqian Zhang教授</a>在此领域做了许多非常杰出的工作。缓存通过数据共享来加快数据访问，也就是说缓存命中与失效对应的响应时间是有差别的，攻击者正是利用这种时间的差异性来推测缓存中的信息，从而获得隐私数据。缓存侧信道攻击主要有<a href="https://dl.acm.org/citation.cfm?id=2725064" target="_blank" rel="external">Evict+Time</a>、<a href="http://palms.ee.princeton.edu/system/files/SP_vfinal.pdf" target="_blank" rel="external">Prime+Probe</a>与<a href="https://www.usenix.org/node/184416" target="_blank" rel="external">Flush+Reload</a>等攻击方式，这里主要简单介绍一下Flush+Reload，也是下文exploit中利用的方法。假设攻击者和目标程序共享物理内存（也可以是云中不同虚拟机共享内存），攻击者可以反复利用处理器指令将监控的内存块（某些地址）从缓存中驱逐出去，然后在等待目标程序访问共享内存（Flush阶段）。然后攻击者重新加载监控的内存块并测量读取时间(Reload阶段)，如果该内存块被目标程序访问过，则访问时间将会较短，因为这时数据已经在缓存中。通过测量加载时间的长短，攻击者可以清楚地知道该内存块是否被目标程序读取过。</p>
<p>Meltdown与Spectre利用这种侧信道可以进行越权内存访问，甚至读取整个内核的内存数据。</p>
<p>以一个简化的Meltdown攻击指令序列为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">; rcx = kernel address</div><div class="line">; rbx = target_array</div><div class="line">mov al, byte [rcx]</div><div class="line">shl rax, 0xc</div><div class="line">mov rbx, qword [rbx + rax]</div></pre></td></tr></table></figure>
<ol>
<li><p>rcx寄存器存放用户空间程序不可访问的内核地址</p>
</li>
<li><p>rbx寄存器指向目标数组target_array</p>
</li>
<li><p>一个具有用户级权限的攻击者在第三条指令中试图访问内核地址，处理器会对其作安全检查，检查该进程是否有权限访问该地址，于是这条指令会触发异常，该指令及之后的指令对寄存器的修改都会被丢弃，处理器重新回到能正常执行的指令中。但由于处理器采用乱序执行方式，在等待处理器完成该指令执行的同时（权限检查结束之前），后面两条指令已经被执行了（尽管最终会被丢弃）。</p>
</li>
<li><p>将指令3读取到的数据乘以4096（4KB），至于为什么是4096，会在下文具体exploit中介绍。</p>
</li>
<li><p>将指令4的结果作为索引对目标数组target_array(rbx[al*4096])进行访问。由于一个内存页的大小是4KB，不同的数据将会导致不同的内存页被访问并存放到CPU缓存中。</p>
</li>
</ol>
<p>此后，攻击者就可以通过缓存侧信道攻击，不断遍历加载rbx[al*4096]，由于该数据此时已经在缓存中，攻击者总会遍历出一个加载时间远小于其它的数据，推测哪个内存页被访问过了，从而推断出被访问的内核内存数据。</p>
<h2 id="0X02-Exploit-案例"><a href="#0X02-Exploit-案例" class="headerlink" title="0X02 Exploit 案例"></a>0X02 Exploit 案例</h2><p>来看在github上爆出的一个<a href="https://github.com/paboldin/meltdown-exploit/" target="_blank" rel="external">POC</a>，也是目前来看比较能让大家深入理解meltdown的一个exploit。该POC能利用应用程序读取内核中的linux_proc_banner变量，这个变量存储了Linux内核的版本信息，可以通过命令cat /proc/version获取。cat /proc/version触发了系统调用将linux_proc_banner变量的信息返回给应用程序。而利用meltdown漏洞可以直接从应用程序中访问linux_proc_banner变量，破坏了内存隔离。<br>该POC首先利用“sudo cat /proc/kallsyms | grep “linux_proc_banner””获取linux_proc_banner在内核中的地址，再读取该地址上的值。从该地址读取变量的值正是利用了meltdown漏洞。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/banner.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/banner.png" width="550"></a><br>    <figcaption></figcaption><br></figure>


<p>用gdb调试meltdown可执行程序</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/gdb.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/gdb.png" width="550"></a><br>    <figcaption></figcaption><br></figure>


<p>可以看到spcculate函数会触发段错误，而speculate函数也正是该POC最关键的代码，其由一段汇编代码组成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">  lea %[target], %%rbx\n\t&quot;</div><div class="line">&quot;1:\n\t&quot;</div><div class="line"></div><div class="line">&quot;.rept 300\n\t&quot;</div><div class="line">&quot;add $0x141, %%rax\n\t&quot;</div><div class="line">&quot;.endr\n\t&quot;</div><div class="line"></div><div class="line">&quot;movzx (%[addr]), %%eax\n\t&quot;</div><div class="line">&quot;shl $12, %%rax\n\t&quot;</div><div class="line">&quot;movzx (%%rbx, %%rax, 1), %%rbx\n&quot;</div><div class="line"></div><div class="line">&quot;stopspeculate: \n\t&quot;</div><div class="line">&quot;nop\n\t&quot;</div><div class="line">:</div><div class="line">: [target] &quot;m&quot; (target_array),</div><div class="line">[addr] &quot;r&quot; (addr)</div><div class="line">: &quot;rax&quot;, &quot;rbx&quot;</div></pre></td></tr></table></figure>
<p>该函数的目的是欺骗CPU的乱序执行机制。此处是AT&amp;T 汇编语法，AT&amp;T格式的汇编指令是“源操作数在前，目的操作数在后”，而intel格式是反过来的，如下：</p>
<p>lea %[target], %%rbx 把全局变量targetc_array的地址放到RBX寄存器中, target_array正好设置为256*4096字节大小，这个设置也是有讲究的，一个字节的取值范围正是0-255，共256个数。4096正好是x86架构中一个页面的大小。<br>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define TARGET_OFFSET	12</div><div class="line">#define TARGET_SIZE	(1 &lt;&lt; TARGET_OFFSET)</div><div class="line">#define BITS_READ	8</div><div class="line">#define VARIANTS_READ	(1 &lt;&lt; BITS_READ)</div><div class="line"></div><div class="line">static char target_array[VARIANTS_READ * TARGET_SIZE];</div></pre></td></tr></table></figure>
<p>add $0x141, %%rax是一条加法指令，会重复300次，这条指令的作用只是测试处理器能乱序执行成功。</p>
<p>movzx (%[addr]), %%eax 对应上一章节指令序列的第三条指令，将攻击者的目标内核地址所指向的数据放入eax寄存器中，该操作会触发处理器异常</p>
<p>shl $12, %%rax对应上一章节指令序列第四条指令，左移12位，也就是乘以4096，大小与target_array数组的列相等，为推测内核地址指向的数据做准备。</p>
<p>movzx (%%rbx, %%rax, 1), %%rbx对应上一章节指令序列第五条指令，以目标内核地址指向的数据乘以4096作为索引访问target_array数组，这时，不同的数据将会被加载到不同的缓存页面中。这个过程正是Reload阶段做的事情。</p>
<p>在调用speculate函数窃取数据之前，攻击者会故意冲洗掉target_array的缓存（Flush阶段），由clflush_target函数实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void clflush_target(void)</div><div class="line">&#123;</div><div class="line">	int i;</div><div class="line"></div><div class="line">	for (i = 0; i &lt; VARIANTS_READ; i++)</div><div class="line">		_mm_clflush(&amp;target_array[i * TARGET_SIZE]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行完movzx (%%rbx, %%rax, 1)指令之后，处理器开始处理异常，攻击者则注册一个信号处理器，直接修改程序指针寄存器，将执行位置跳转到stopspeculate指令继续执行即nop指令</p>
<p>执行完speculate函数之后，开始执行check函数，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void check(void)</div><div class="line">&#123;</div><div class="line">	int i, time, mix_i;</div><div class="line">	volatile char *addr;</div><div class="line"></div><div class="line">	for (i = 0; i &lt; VARIANTS_READ; i++) &#123;</div><div class="line">		mix_i = ((i * 167) + 13) &amp; 255;</div><div class="line"></div><div class="line">		addr = &amp;target_array[mix_i * TARGET_SIZE];</div><div class="line">		time = get_access_time(addr);</div><div class="line"></div><div class="line">		if (time &lt;= cache_hit_threshold)</div><div class="line">			hist[mix_i]++;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>check函数就是为了检测不同内存数据访问的时间差异来判断被缓存过的数据。<br>由于target_array的大小为256*4096，所以最多只要测试256次，就可以推测出内核地址指向的数据是否被访问过了。<br>至此，窃据数据过程完成。</p>
<p>下图为该POC的运行结果： </p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/result.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/result.png" width="550"></a><br>    <figcaption></figcaption><br></figure>

<p>该利用程序是一个一个字节读取linux_proc_banner地址中的内容，可以运行cat /proc/version命令，窃取的数据和该命令的运行结果是一致的。可见攻击者成功执行攻击。</p>
<h2 id="0X03-漏洞危害"><a href="#0X03-漏洞危害" class="headerlink" title="0X03 漏洞危害"></a>0X03 漏洞危害</h2><p>Meltdown与Spectre本质上都是基于缓存侧信道的攻击。<br>对于个人终端用户，利用Meltdown与Spectre漏洞，低权限用户可以访问内核的内容，泄露本地操作系统底层的信息、秘钥信息等，通过获取泄露的信息，可以绕过内核的隔离防护;如果配合其它漏洞，可以利用该漏洞泄露内核模块地址绕过KASLR等防护机制实现其他类型的攻击进行提权。另外，利用浏览器JIT特性预测执行特殊的JIT代码，从而读取整个浏览器内存中的数据，泄露用户帐号，密码，邮箱, cookie等隐私信息。</p>
<p>对于云服务中的虚拟机，可以通过相关攻击机制获取完整的物理机的CPU缓存数据，绕过虚拟机超级管理器（Hypervisor）的隔离防护，以泄露其它租户隐私信息。</p>
<p>然而Meltdown与Spectre主要用于信息泄露，并不能对目标内存地址进行任意修改。攻击者必须要有执行权限才能进行攻击，对于一般用户只要不被执行恶意代码（比如访问恶意网站），就不会被Meltdown与Spectre攻击。但是在云端，攻击者可以租赁虚拟机来执行攻击者想要执行的任意代码，从而获取宿主物理机以及其它租户的信息。可见此次CPU漏洞对各云服务商冲击还是非常大的。</p>
<p>各大云厂商也分别针对此次芯片漏洞发布应对公告。<br>AWS: 此项安全漏洞广泛存在于过去20年推出的英特尔、AMD以及ARM等各类现代处理器架构当中，影响范围涵盖服务器、台式机以及移动设备。Amazon EC2体系中除极少数实例外，其余皆受到严格保护。剩余部分的修复工作将在接下来数小时内完成，并附有相关实例维护通知。虽然AWS所执行的更新能够切实保护底层基础设施，但为了充分解决此次问题，客户还应对实例中的操作系统进行修复。目前Amazon Linux更新已经开始发布，具体如下：<br><a href="https://aws.amazon.com/security/security-bulletins/AWS-2018-013/" target="_blank" rel="external">https://aws.amazon.com/security/security-bulletins/AWS-2018-013/</a></p>
<p>阿里云：为解决处理器芯片的安全问题，阿里云将在北京时间2018年1月12日凌晨1点进行虚拟化底层的升级更新。届时，阿里云将采用热升级的方式，绝大多数客户不会受到影响。但个别客户可能需要手动重启，阿里云建议客户提前准备运营预案及数据备份。</p>
<p>腾讯云：腾讯云将于北京时间2018年1月10日凌晨01:00-05:00通过热升级技术对硬件平台和虚拟化平台进行后端修复，期间客户业务不会受到影响。对于极少量不支持热升级方式的，腾讯云另行安排时间手动重启修复，这部分服务器腾讯云安全团队将会另行进行通知，协商升级时间。</p>
<p>华为云：1、平台侧安全，按原定计划，于北京时间2018年1月11日0时，启动基础平台安全升级，方式为对客户无感知的热升级，正常情况下对客户业务无影响。升级过程中，可能需要部分客户配合实施重启。建议客户根据业务情况，提前准备运营预案，妥善备份重要数据(点击了解云硬盘备份)。2、租户侧安全，推出漏洞消减服务，可帮助客户对漏洞可能造成的威胁进行检测及防御。服务已于北京时间2018年1月6日22时上线。客户可通过电话预约使用该服务。</p>
<p>针对Meltdown与Spectre攻击的防御措施以及其它影响后续文章继续。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://googleprojectzero.blogspot.hk/2018/" target="_blank" rel="external">https://googleprojectzero.blogspot.hk/2018/</a></li>
<li><a href="https://github.com/paboldin/meltdown-exploit" target="_blank" rel="external">https://github.com/paboldin/meltdown-exploit</a></li>
<li><a href="https://meltdownattack.com/meltdown.pdf" target="_blank" rel="external">https://meltdownattack.com/meltdown.pdf</a></li>
<li><a href="https://spectreattack.com/spectre.pdf" target="_blank" rel="external">https://spectreattack.com/spectre.pdf</a></li>
<li><a href="https://www.usenix.org/node/184416" target="_blank" rel="external">https://www.usenix.org/node/184416</a></li>
<li><a href="http://palms.ee.princeton.edu/system/files/SP_vfinal.pdf" target="_blank" rel="external">http://palms.ee.princeton.edu/system/files/SP_vfinal.pdf</a></li>
<li><a href="https://dl.acm.org/citation.cfm?id=2725064" target="_blank" rel="external">https://dl.acm.org/citation.cfm?id=2725064</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32654221" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/32654221</a></li>
<li><a href="https://weibo.com/ttarticle/p/show?id=2309404192925885035405" target="_blank" rel="external">https://weibo.com/ttarticle/p/show?id=2309404192925885035405</a></li>
</ol>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Meltdown/">Meltdown</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spectre/">Spectre</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vulnerability/">Vulnerability</a></li></ul>

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/21111111/welcome/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          「善守者 敌不知其所攻」
        
      </div>
    </a>
  
  
    <a href="/20171124/ever-papernote4/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Thwarting Memory Disclosure with Efficient Hypervisor-enforced Intra-domain Isolation&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>




<div class="share_addthis">
  <div class="sharing addthis_toolbox share">
    <a class="addthis_button_facebook_like"></a>
    <a class="addthis_button_tweet"></a>
    <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-560c64c35486b3d4" async="async"></script>
</div>





</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Diting0x&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
</body>
</html>